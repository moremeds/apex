@startuml classes_domain_services
set namespaceSeparator none
class "AccountType" as apex.src.domain.services.regime.models.AccountType {
  name
}
class "ActionContext" as apex.src.domain.services.regime.models.ActionContext {
  delta_max : Optional[float]
  delta_min : Optional[float]
  dte_max : Optional[int]
  dte_min : Optional[int]
  max_loss_per_trade : Optional[float]
  position_type : str
  rationale : str
  require_profit_target : bool
  require_stop : bool
  size_factor : float
  warnings : List[str]
  to_dict() -> Dict[str, Any]
}
class "AnalysisMetrics" as apex.src.domain.services.regime.param_recommender.AnalysisMetrics {
  boundary_tolerance : float
  chop_above_threshold_pct : float
  chop_boundary_density : float
  chop_proxy_current : float
  chop_proxy_mean : float
  chop_threshold : float
  concern_level : float
  vol_above_threshold_pct : float
  vol_boundary_density : float
  vol_proxy_current : float
  vol_proxy_mean : float
  vol_threshold : float
  to_dict() -> Dict[str, Any]
}
class "BarCountCalculator" as apex.src.domain.services.bar_count_calculator.BarCountCalculator {
  BARS_PER_EARLY_DAY : ClassVar[Dict[str, float]]
  BARS_PER_HOUR : ClassVar[Dict[str, float]]
  BARS_PER_REGULAR_DAY : ClassVar[Dict[str, float]]
  calendar_name : str
  calculate(symbol: str, timeframe: str, start: date | datetime, end: date | datetime) -> ExpectedBarCount
  count_trading_days(start: date, end: date) -> int
  get_bars_per_day(timeframe: str, is_early_close: bool) -> float
  get_bars_per_hour(timeframe: str) -> float
  get_early_close_days(start: date, end: date) -> List[TradingSession]
  get_next_trading_day(reference_date: date | datetime | None, max_lookahead_days: int) -> date
  get_previous_trading_day(reference_date: date | datetime | None, max_lookback_days: int) -> date
  get_trading_days(start: date, end: date) -> List[date]
  get_trading_sessions(start: date, end: date) -> List[TradingSession]
  is_trading_day(check_date: date | datetime) -> bool
}
class "BarReplayService" as apex.src.domain.services.bar_replay_service.BarReplayService {
  TIMEFRAME_SECONDS : Dict[str, int]
  get_validation(symbol: str, timeframe: str, start: Optional[date | datetime], end: Optional[date | datetime]) -> ValidationResult
  pause() -> None
  replay(symbol: str, timeframe: str, start: Optional[date | datetime], end: Optional[date | datetime], speed: ReplaySpeed, speed_multiplier: float, on_progress: Optional[Callable[[ReplayProgress], None]], on_gap: Optional[Callable[[ReplayGapEvent], None]], progress_interval: int) -> ReplayProgress
  replay_all(symbols: List[str], timeframes: List[str], start: Optional[date | datetime], end: Optional[date | datetime], speed: ReplaySpeed, speed_multiplier: float, on_progress: Optional[Callable[[ReplayProgress], None]], on_gap: Optional[Callable[[ReplayGapEvent], None]], progress_interval: int) -> Dict[Tuple[str, str], ReplayProgress]
  resume() -> None
  step() -> Optional[BarCloseEvent]
  stop() -> None
}
class "CombinedObjectiveResult" as apex.src.domain.services.regime.objectives.CombinedObjectiveResult {
  objective_results : List[ObjectiveResult]
  param_set : Dict[str, Any]
  total_score : float
  to_dict() -> Dict[str, Any]
}
class "Contributor" as apex.src.domain.services.suggester.Contributor {
  contribution : float
  contribution_pct : float
  symbol : str
  underlying : str
}
class "CorrelationAnalyzer" as apex.src.domain.services.correlation_analyzer.CorrelationAnalyzer {
  beta_reference
  concentration_threshold : Threshold
  config : Dict[str, Any]
  enabled
  max_sector_concentration_pct
  sector_map : dict
  calculate_beta_weighted_delta(snapshot: RiskSnapshot, beta_map: Optional[Dict[str, float]]) -> float
  check(snapshot: RiskSnapshot) -> List[RiskSignal]
  get_sector_breakdown(snapshot: RiskSnapshot) -> Dict[str, Dict[str, float]]
}
class "DataValidator" as apex.src.domain.services.data_validator.DataValidator {
  ACCEPTABLE_THRESHOLD : float
  CAUTION_THRESHOLD : float
  COMPLETE_THRESHOLD : float
  PRICE_SPIKE_THRESHOLD : float
  TIMEFRAME_SECONDS : Dict[str, int]
  detect_anomalies(bars: List[BarData]) -> List[ValidationAnomaly]
  detect_gaps(bars: List[BarData], timeframe: str) -> List[ValidationGap]
  generate_report(results: Dict[Tuple[str, str], ValidationResult], format: Literal['text', 'json']) -> str
  validate(symbol: str, timeframe: str, start: Optional[date | datetime], end: Optional[date | datetime]) -> ValidationResult
  validate_all(symbols: Optional[List[str]], timeframes: Optional[List[str]]) -> Dict[Tuple[str, str], ValidationResult]
}
class "DetectedStrategy" as apex.src.domain.services.strategy_detector.DetectedStrategy {
  is_credit : bool
  max_profit : Optional[float]
  max_risk : Optional[float]
  metadata : Dict
  net_delta : float
  net_gamma : float
  net_quantity : float
  net_vega : float
  positions : List[Position]
  strategy_type : str
  underlying : str
  strategy_id() -> str
}
class "EnhancedParamRecommender" as apex.src.domain.services.regime.param_recommender.EnhancedParamRecommender {
  lookback_days : int
  traditional_recommender
  wfo_config
  wfo_optimizer
  analyze(symbol: str, ohlcv: pd.DataFrame, current_params: Dict[str, Any], analysis_date: Optional[date]) -> EnhancedRecommenderResult
}
class "EnhancedRecommenderResult" as apex.src.domain.services.regime.param_recommender.EnhancedRecommenderResult {
  analysis_date : date
  current_params : Dict[str, Any]
  fold_agreement : Dict[str, float]
  has_recommendations : bool
  n_folds : int
  objective_summary : Dict[str, float]
  param_stability : Dict[str, float]
  recommendations : Dict[str, Dict[str, Any]]
  symbol : str
  total_score_mean : float
  total_score_std : float
  training_window : tuple[date, date]
  validation_window : tuple[date, date]
  why_not_changed : List[str]
  to_dict() -> Dict[str, Any]
}
class "EventRiskDetector" as apex.src.domain.services.event_risk_detector.EventRiskDetector {
  config : Dict[str, Any]
  earnings_calendar : dict
  earnings_critical_days
  earnings_threshold : Threshold
  earnings_warning_days
  enabled
  check(snapshot: RiskSnapshot) -> List[RiskSignal]
  cleanup_past_earnings() -> None
  get_upcoming_earnings(days: int) -> Dict[str, date]
  remove_earnings_date(symbol: str) -> None
  update_earnings_date(symbol: str, earnings_date: date) -> None
}
class "ExpectedBarCount" as apex.src.domain.services.bar_count_calculator.ExpectedBarCount {
  bars_per_early_day : float
  bars_per_regular_day : float
  calendar_name : str
  early_close_days : int
  end : date
  expected_bars : int
  start : date
  symbol : str
  timeframe : str
  total_session_hours : float
  trading_days : int
}
class "FoldResult" as apex.src.domain.services.regime.param_optimizer.FoldResult {
  fold_id : int
  objective_result
  suggested_changes : Dict[str, float]
  test_end : date
  test_start : date
  train_end : date
  train_start : date
  to_dict() -> Dict[str, Any]
}
class "HierarchicalRegime" as apex.src.domain.services.regime.models.HierarchicalRegime {
  account_type
  action
  action_context
  alerts : List[str]
  market_confidence : int
  market_regime
  market_symbol : str
  sector_confidence : Optional[int]
  sector_regime : Optional[MarketRegime]
  sector_symbol : Optional[str]
  stock_confidence : Optional[int]
  stock_regime : Optional[MarketRegime]
  symbol : str
  timestamp : datetime
  weekly_veto_active : bool
  to_dict() -> Dict[str, Any]
}
class "MDQC" as apex.src.domain.services.mdqc.MDQC {
  enforce_bid_ask_sanity : bool
  ignore_zero_quotes : bool
  stale_seconds : int
  get_missing_greeks(market_data: Dict[str, MarketData]) -> List[str]
  get_stale_symbols(market_data: Dict[str, MarketData]) -> List[str]
  get_suspicious_symbols(market_data: Dict[str, MarketData]) -> List[str]
  validate_all(market_data: Dict[str, MarketData]) -> Dict[str, MarketData]
  validate_single(md: MarketData) -> DataQuality
}
class "MarketAlertDetector" as apex.src.domain.services.market_alert_detector.MarketAlertDetector {
  config : dict
  drop_critical
  drop_threshold : Threshold
  drop_warning
  vix_critical
  vix_spike_pct
  vix_threshold : Threshold
  vix_warning
  vol_threshold : Threshold
  detect_alerts(market_data: Dict[str, Any]) -> List[Dict[str, Any]]
  reset_state() -> None
}
class "MarketSymbol" as apex.src.domain.services.regime.universe_loader.MarketSymbol {
  name : str
  role : str
  symbol : str
}
class "ObjectiveEvaluator" as apex.src.domain.services.regime.objectives.ObjectiveEvaluator {
  objectives : list
  evaluate(ohlcv: pd.DataFrame, regime_series: pd.Series, params: Dict[str, Any]) -> CombinedObjectiveResult
  get_objective_summary() -> Dict[str, Dict[str, Any]]
}
class "ObjectiveFunction" as apex.src.domain.services.regime.objectives.ObjectiveFunction {
  direction : str
  name : str
  weight : float
  {abstract}evaluate(ohlcv: pd.DataFrame, regime_series: pd.Series, params: Dict[str, Any]) -> ObjectiveResult
}
class "ObjectiveResult" as apex.src.domain.services.regime.objectives.ObjectiveResult {
  details : Dict[str, Any]
  direction : str
  name : str
  value : float
  weight : float
  weighted_value : float
  to_dict() -> Dict[str, Any]
}
class "ParamProvenance" as apex.src.domain.services.regime.param_provenance.ParamProvenance {
  dsr_ok : bool
  dsr_threshold : float
  dsr_value : Optional[float]
  group : Optional[str]
  is_validated : bool
  oos_ok : bool
  oos_sharpe : Optional[float]
  param_set_id : str
  pbo_ok : bool
  pbo_threshold : float
  pbo_value : Optional[float]
  source : str
  symbol : str
  trained_data_end : Optional[date]
  trainer_version : Optional[str]
  validation_passed : bool
  walk_forward_folds : Optional[int]
  compute_param_set_id(params: Dict[str, Any], symbol: str, trained_data_end: Optional[date]) -> str
  from_params(params: Dict[str, Any], symbol: str, source: str, group: Optional[str], trained_data_end: Optional[date], trainer_version: Optional[str]) -> 'ParamProvenance'
  to_dict() -> Dict[str, Any]
}
class "ParamProvenanceSet" as apex.src.domain.services.regime.param_provenance.ParamProvenanceSet {
  param_sources : Dict[str, ParamSource]
  provenance
  symbol : str
  get_params_by_source(source: str) -> Dict[str, ParamSource]
  to_dict() -> Dict[str, Any]
}
class "ParamRecommendation" as apex.src.domain.services.regime.param_recommender.ParamRecommendation {
  change : float
  confidence : float
  current_value : float
  evidence
  param_name : str
  reason : str
  requires_manual_review : bool
  suggested_value : float
  to_dict() -> Dict[str, Any]
}
class "ParamRecommender" as apex.src.domain.services.regime.param_recommender.ParamRecommender {
  BOUNDARY_CONCERN_LEVEL : float
  BOUNDARY_TOLERANCE : int
  MAX_CHANGE_PER_RUN : int
  MIN_EVIDENCE_EVENTS : int
  MIN_EVIDENCE_SPREAD_DAYS : int
  lookback_days : int
  vol_proxy
  analyze(symbol: str, ohlcv: pd.DataFrame, current_params: Dict[str, Any], analysis_date: Optional[date]) -> RecommenderResult
}
class "ParamSource" as apex.src.domain.services.regime.param_provenance.ParamSource {
  param_name : str
  source : str
  trained_on : Optional[date]
  value : Any
  to_dict() -> Dict[str, Any]
}
class "ParamStability" as apex.src.domain.services.regime.param_optimizer.ParamStability {
  agreement_ratio : float
  changes_by_fold : List[float]
  mean_change : float
  param_name : str
  std_change : float
  suggested_direction : str
  to_dict() -> Dict[str, Any]
}
class "PositionRiskAnalyzer" as apex.src.domain.services.position_risk_analyzer.PositionRiskAnalyzer {
  stop_loss_pct
  stop_loss_threshold : Threshold
  take_profit_pct
  take_profit_threshold : Threshold
  trailing_stop_drawdown
  trailing_stop_threshold : Threshold
  check(pos_risk: PositionRisk) -> List[RiskSignal]
}
class "RecommendationEvidence" as apex.src.domain.services.regime.param_recommender.RecommendationEvidence {
  boundary_density : float
  boundary_metric_is_percentile : bool
  boundary_tolerance : float
  boundary_window : int
  clustered_events : bool
  event_dates : List[str]
  false_positive_count : int
  lookback_days : int
  missed_count : int
  vol_proxy_name : str
  vol_proxy_params : Dict[str, Any]
  to_dict() -> Dict[str, Any]
}
class "RecommenderResult" as apex.src.domain.services.regime.param_recommender.RecommenderResult {
  analysis_date : date
  analysis_metrics : Optional[AnalysisMetrics]
  boundary_density_ok : Optional[bool]
  current_params : Dict[str, Any]
  false_positives_below_threshold : Optional[int]
  has_recommendations : bool
  lookback_days : int
  missed_events_below_threshold : Optional[int]
  no_change_reason : Optional[str]
  recommendations : List[ParamRecommendation]
  symbol : str
  to_dict() -> Dict[str, Any]
}
class "Reconciler" as apex.src.domain.services.pos_reconciler.Reconciler {
  stale_threshold_seconds : int
  merge_all_positions(positions_by_source: Dict[str, List[Position]]) -> List[Position]
  merge_positions(ib_positions: List[Position], manual_positions: List[Position], futu_positions: Optional[List[Position]]) -> List[Position]
  reconcile(ib_positions: List[Position], manual_positions: List[Position], cached_positions: List[Position], futu_positions: Optional[List[Position]]) -> List[ReconciliationIssue]
  remove_expired_options(positions: List[Position], ref_date: Optional[datetime]) -> List[Position]
}
class "RegimeStabilityObjective" as apex.src.domain.services.regime.objectives.RegimeStabilityObjective {
  evaluate(ohlcv: pd.DataFrame, regime_series: pd.Series, params: Dict[str, Any]) -> ObjectiveResult
}
class "ReplayGapEvent" as apex.src.domain.services.bar_replay_service.ReplayGapEvent {
  after_timestamp : datetime
  before_timestamp : datetime
  expected_bars : int
  gap_duration : timedelta
  gap_hours : float
}
class "ReplayProgress" as apex.src.domain.services.bar_replay_service.ReplayProgress {
  bars_per_second : float
  current_timestamp : Optional[datetime]
  elapsed_seconds : float
  eta_seconds : Optional[float]
  gaps_detected : int
  progress_pct : float
  remaining_bars : int
  replayed_bars : int
  start_time : float
  symbol : str
  timeframe : str
  total_bars : int
}
class "ReplaySpeed" as apex.src.domain.services.bar_replay_service.ReplaySpeed {
  name
}
class "SectorConfig" as apex.src.domain.services.regime.universe_loader.SectorConfig {
  etf : str
  name : str
  stocks : List[str]
}
class "SimpleSuggester" as apex.src.domain.services.suggester.SimpleSuggester {
  top_delta_contributors(positions: List[Position], market_data: Dict[str, MarketData], snapshot: RiskSnapshot, top_n: int) -> List[Contributor]
  top_notional_contributors(positions: List[Position], market_data: Dict[str, MarketData], snapshot: RiskSnapshot, top_n: int) -> List[Contributor]
  top_vega_contributors(positions: List[Position], market_data: Dict[str, MarketData], snapshot: RiskSnapshot, top_n: int) -> List[Contributor]
}
class "StrategyDetector" as apex.src.domain.services.strategy_detector.StrategyDetector {
  detect(positions: List[Position]) -> List[DetectedStrategy]
  get_stats() -> Dict[str, int]
}
class "StrategyRiskAnalyzer" as apex.src.domain.services.strategy_risk_analyzer.StrategyRiskAnalyzer {
  calendar_iv_crush_threshold
  config : Dict[str, Any]
  credit_spread_r_multiple
  diagonal_delta_flip_warning
  check(strategy: DetectedStrategy, position_risk_map: Dict[str, PositionRisk]) -> List[RiskSignal]
}
class "TradingAction" as apex.src.domain.services.regime.models.TradingAction {
  allows_new_positions : bool
  display_name : str
  name
  requires_defined_risk : bool
}
class "TradingProxyObjective" as apex.src.domain.services.regime.objectives.TradingProxyObjective {
  forward_bars : int
  evaluate(ohlcv: pd.DataFrame, regime_series: pd.Series, params: Dict[str, Any]) -> ObjectiveResult
}
class "TradingSession" as apex.src.domain.services.bar_count_calculator.TradingSession {
  date : date
  is_early_close : bool
  market_close : datetime
  market_open : datetime
  session_hours : float
}
class "TurningPointQualityObjective" as apex.src.domain.services.regime.objectives.TurningPointQualityObjective {
  evaluate(ohlcv: pd.DataFrame, regime_series: pd.Series, params: Dict[str, Any]) -> ObjectiveResult
}
class "UniverseConfig" as apex.src.domain.services.regime.universe_loader.UniverseConfig {
  all_symbols : List[str]
  market_benchmarks : Set[str]
  market_symbols : List[MarketSymbol]
  quick_test : List[str]
  sector_etfs : List[str]
  sector_names : Dict[str, str]
  sectors : Dict[str, SectorConfig]
  stock_to_sector : Dict[str, str]
  get_sector_for_symbol(symbol: str) -> Optional[str]
}
class "<color:red>UniverseLoadError</color>" as apex.src.domain.services.regime.universe_loader.UniverseLoadError {
}
class "ValidationAnomaly" as apex.src.domain.services.data_validator.ValidationAnomaly {
  anomaly_type : Literal['duplicate', 'out_of_order', 'price_spike', 'zero_volume', 'ohlc_invalid']
  details : str
  severity : Literal['low', 'medium', 'high']
  timestamp : datetime
}
class "ValidationGap" as apex.src.domain.services.data_validator.ValidationGap {
  duration : timedelta
  duration_hours : float
  end : datetime
  expected_bars : int
  gap_type : Literal['missing', 'weekend', 'holiday', 'after_hours']
  start : datetime
}
class "ValidationResult" as apex.src.domain.services.data_validator.ValidationResult {
  actual_bars : int
  anomalies : List[ValidationAnomaly]
  coverage_pct : float
  duplicate_count : int
  early_close_days : int
  end : date
  expected_bars : int
  gap_count : int
  gaps : List[ValidationGap]
  is_valid : bool
  out_of_order_count : int
  start : date
  status
  symbol : str
  timeframe : str
  total_gap_bars : int
  trading_days : int
  validated_at : datetime
  validation_duration_ms : float
}
class "ValidationStatus" as apex.src.domain.services.data_validator.ValidationStatus {
  name
}
class "VolProxyConfig" as apex.src.domain.services.regime.param_recommender.VolProxyConfig {
  annualization : int
  name : str
  reference_window : int
  window : int
  calculate(ohlcv: pd.DataFrame) -> pd.Series
  to_dict() -> Dict[str, Any]
}
class "WalkForwardConfig" as apex.src.domain.services.regime.param_optimizer.WalkForwardConfig {
  embargo_days : int
  label_horizon_days : int
  min_fold_agreement : float
  n_folds : int
  purge_gap_days : int
  test_days : int
  train_days : int
  to_dict() -> Dict[str, Any]
}
class "WalkForwardOptimizer" as apex.src.domain.services.regime.param_optimizer.WalkForwardOptimizer {
  MAX_CHANGE : dict
  PARAM_BOUNDS : dict
  config
  evaluator
  optimize(symbol: str, ohlcv: pd.DataFrame, current_params: Dict[str, Any]) -> WalkForwardResult
}
class "WalkForwardResult" as apex.src.domain.services.regime.param_optimizer.WalkForwardResult {
  config
  fold_results : List[FoldResult]
  objective_summary : Dict[str, float]
  param_stability : Dict[str, ParamStability]
  recommendations : Dict[str, Dict[str, Any]]
  symbol : str
  total_score_mean : float
  total_score_std : float
  why_not_changed : List[str]
  to_dict() -> Dict[str, Any]
}
apex.src.domain.services.regime.objectives.RegimeStabilityObjective --|> apex.src.domain.services.regime.objectives.ObjectiveFunction
apex.src.domain.services.regime.objectives.TradingProxyObjective --|> apex.src.domain.services.regime.objectives.ObjectiveFunction
apex.src.domain.services.regime.objectives.TurningPointQualityObjective --|> apex.src.domain.services.regime.objectives.ObjectiveFunction
apex.src.domain.services.data_validator.ValidationResult --> apex.src.domain.services.data_validator.ValidationStatus : status
apex.src.domain.services.regime.models.HierarchicalRegime --> apex.src.domain.services.regime.models.AccountType : account_type
apex.src.domain.services.regime.models.HierarchicalRegime --> apex.src.domain.services.regime.models.ActionContext : action_context
apex.src.domain.services.regime.models.HierarchicalRegime --> apex.src.domain.services.regime.models.TradingAction : action
apex.src.domain.services.regime.param_optimizer.FoldResult --> apex.src.domain.services.regime.objectives.CombinedObjectiveResult : objective_result
apex.src.domain.services.regime.param_optimizer.WalkForwardOptimizer --> apex.src.domain.services.regime.objectives.ObjectiveEvaluator : evaluator
apex.src.domain.services.regime.param_optimizer.WalkForwardOptimizer --> apex.src.domain.services.regime.param_optimizer.WalkForwardConfig : config
apex.src.domain.services.regime.param_optimizer.WalkForwardResult --> apex.src.domain.services.regime.param_optimizer.WalkForwardConfig : config
apex.src.domain.services.regime.param_provenance.ParamProvenanceSet --> apex.src.domain.services.regime.param_provenance.ParamProvenance : provenance
apex.src.domain.services.regime.param_recommender.ParamRecommendation --> apex.src.domain.services.regime.param_recommender.RecommendationEvidence : evidence
apex.src.domain.services.regime.param_recommender.ParamRecommender --> apex.src.domain.services.regime.param_recommender.VolProxyConfig : vol_proxy
apex.src.domain.services.regime.param_optimizer.WalkForwardConfig --* apex.src.domain.services.regime.param_recommender.EnhancedParamRecommender : wfo_config
apex.src.domain.services.regime.param_optimizer.WalkForwardOptimizer --* apex.src.domain.services.regime.param_recommender.EnhancedParamRecommender : wfo_optimizer
apex.src.domain.services.regime.param_recommender.ParamRecommender --* apex.src.domain.services.regime.param_recommender.EnhancedParamRecommender : traditional_recommender
@enduml
