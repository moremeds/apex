@startuml classes_infrastructure_adapters
set namespaceSeparator none
class "AccountFetcher" as apex.src.infrastructure.adapters.futu.account_fetcher.AccountFetcher {
  fetch() -> AccountInfo
  get_cached() -> Optional[AccountInfo]
}
class "BrokerManager" as apex.src.infrastructure.adapters.broker_manager.BrokerManager {
  check_all_health() -> Dict[str, BrokerStatus]
  connect() -> None
  disconnect() -> None
  fetch_account_info() -> AccountInfo
  fetch_account_info_by_broker() -> Dict[str, AccountInfo]
  fetch_orders(include_open: bool, include_completed: bool, days_back: int) -> List[Order]
  fetch_positions() -> List[Position]
  fetch_positions_by_broker() -> Dict[str, List[Position]]
  fetch_trades(days_back: int) -> List[Trade]
  get_adapter(name: str) -> Optional[BrokerAdapter]
  get_all_status() -> Dict[str, BrokerStatus]
  get_status(name: str) -> Optional[BrokerStatus]
  is_connected() -> bool
  register_adapter(name: str, adapter: BrokerAdapter) -> None
  set_health_monitor(health_monitor: 'HealthMonitor') -> None
  set_position_callback(callback: Callable[[str, List[Position]], None]) -> None
  subscribe_positions() -> None
  unsubscribe_positions() -> None
}
class "BrokerStatus" as apex.src.infrastructure.adapters.broker_manager.BrokerStatus {
  connected : bool
  last_error : Optional[str]
  last_updated : datetime
  name : str
  position_count : int
}
class "CachedData" as apex.src.infrastructure.adapters.yahoo.adapter.CachedData {
  beta : Optional[float]
  data : MarketData
  fetched_at : datetime
}
class "ConnectionPoolConfig" as apex.src.infrastructure.adapters.ib.connection_pool.ConnectionPoolConfig {
  client_ids : Optional[IbClientIdsConfig]
  connect_timeout : int
  host : str
  port : int
}
class "ContractQualificationService" as apex.src.infrastructure.adapters.ib.contract_qualification_service.ContractQualificationService {
  clear_cache() -> None
  clear_expired() -> int
  get_cache_size() -> int
  get_cached(contract: Any) -> Optional[Any]
  get_stats() -> Dict[str, int]
  qualify(contract: Any, callback: Optional[Callable[[Any], Awaitable[None]]]) -> Optional[Any]
  qualify_batch(contracts: List[Any]) -> List[Any]
}
class "FileExperimentTracker" as apex.src.infrastructure.adapters.file_experiment_tracker.FileExperimentTracker {
  compare_to_baseline(symbol: str, new_roc_auc: float, new_pr_auc: float, new_brier: float, improvement_threshold: float) -> ComparisonResult
  get_baseline(symbol: str) -> Optional[BaselineMetrics]
  get_recent_runs(symbol: Optional[str], limit: int) -> List[TrainingRunRecord]
  get_run(run_id: str) -> Optional[TrainingRunRecord]
  record_run(record: TrainingRunRecord) -> None
  set_baseline(symbol: str, metrics: BaselineMetrics) -> None
}
class "FileLoader" as apex.src.infrastructure.adapters.file_loader.FileLoader {
  file_path : Path
  reload_interval_sec : int
  connect() -> None
  disconnect() -> None
  {abstract}fetch_account_info() -> AccountInfo
  {abstract}fetch_orders(include_open: bool, include_completed: bool, days_back: int) -> List[Order]
  fetch_positions() -> List[Position]
  {abstract}fetch_trades(days_back: int) -> List[Trade]
  is_connected() -> bool
}
class "FileModelRegistry" as apex.src.infrastructure.adapters.file_model_registry.FileModelRegistry {
  delete_version(symbol: str, version: str) -> bool
  list_versions(symbol: str) -> List[ModelVersion]
  load_metadata(symbol: str, version: str) -> Optional[ModelMetadata]
  load_model(symbol: str, version: str) -> Optional[Any]
  promote_to_active(symbol: str, candidate_version: str) -> None
  save_candidate(symbol: str, model: Any, metadata: ModelMetadata) -> str
}
class "FutuAdapter" as apex.src.infrastructure.adapters.futu.adapter.FutuAdapter {
  filter_trading_market : str
  host : str
  port : int
  reconnect_backoff_factor : float
  reconnect_backoff_initial : int
  reconnect_backoff_max : int
  security_firm : str
  trd_env : str
  connect() -> None
  disconnect() -> None
  fetch_account_info() -> AccountInfo
  fetch_orders(include_open: bool, include_completed: bool, days_back: int) -> List[Order]
  fetch_positions() -> List[Position]
  fetch_trades(days_back: int) -> List[Trade]
  is_connected() -> bool
  set_position_callback(callback: Callable[[List[Position]], None]) -> None
  subscribe_positions() -> None
  unsubscribe_positions() -> None
}
class "<color:red>FutuAuthError</color>" as apex.src.infrastructure.adapters.futu.exceptions.FutuAuthError {
}
class "<color:red>FutuConnectionError</color>" as apex.src.infrastructure.adapters.futu.exceptions.FutuConnectionError {
}
class "<color:red>FutuDataError</color>" as apex.src.infrastructure.adapters.futu.exceptions.FutuDataError {
}
class "<color:red>FutuError</color>" as apex.src.infrastructure.adapters.futu.exceptions.FutuError {
}
class "<color:red>FutuRateLimitError</color>" as apex.src.infrastructure.adapters.futu.exceptions.FutuRateLimitError {
  cooldown_seconds : int
}
class "FutuTradeHandler" as apex.src.infrastructure.adapters.futu.trade_handler.create_trade_handler.FutuTradeHandler {
  on_recv_rsp(rsp_str: Any) -> None
}
class "IbBaseAdapter" as apex.src.infrastructure.adapters.ib.base.IbBaseAdapter {
  ADAPTER_TYPE : str
  client_id : int
  host : str
  ib : NoneType
  port : int
  reconnect_backoff_factor : float
  reconnect_backoff_initial : int
  reconnect_backoff_max : int
  connect() -> None
  disconnect() -> None
  ensure_connected() -> None
  format_expiry_for_ib(expiry) -> Optional[str]
  get_connection_info() -> dict
  is_connected() -> bool
  publish_event(event_type: Any, payload: dict) -> None
}
class "IbCompositeAdapter" as apex.src.infrastructure.adapters.ib.composite_adapter.IbCompositeAdapter {
  connect() -> None
  disable_streaming() -> None
  disconnect() -> None
  enable_streaming() -> None
  fetch_account_info() -> AccountInfo
  fetch_historical_bars(symbol: str, timeframe: str, start, end, limit: Optional[int])
  fetch_market_data(positions: List[Position]) -> List[MarketData]
  fetch_orders(include_open: bool, include_completed: bool, days_back: int) -> List[Order]
  fetch_positions() -> List[Position]
  fetch_quotes(symbols: List[str]) -> Dict[str, MarketData]
  fetch_trades(days_back: int) -> List[Trade]
  get_connection_info() -> dict
  get_latest(symbol: str) -> Optional[MarketData]
  is_connected() -> bool
  set_streaming_callback(callback: Optional[Callable[[str, MarketData], None]]) -> None
  subscribe(symbols: List[str]) -> None
  supports_greeks() -> bool
  supports_streaming() -> bool
  unsubscribe(symbols: List[str]) -> None
}
class "IbConnectionPool" as apex.src.infrastructure.adapters.ib.connection_pool.IbConnectionPool {
  execution : Optional['IB']
  historical : Optional['IB']
  monitoring : Optional['IB']
  connect() -> None
  connect_execution() -> None
  connect_historical() -> None
  connect_monitoring_only() -> None
  disconnect() -> None
  ensure_connected() -> None
  ensure_execution_connected() -> None
  ensure_historical_connected() -> None
  get_status() -> dict
  is_connected() -> bool
  is_execution_connected() -> bool
  is_historical_connected() -> bool
  is_monitoring_connected() -> bool
}
class "IbExecutionAdapter" as apex.src.infrastructure.adapters.ib.execution_adapter.IbExecutionAdapter {
  ADAPTER_TYPE : str
  ib : NoneType
  cancel_all_orders(symbol: Optional[str]) -> List[OrderResult]
  cancel_order(order_id: str) -> OrderResult
  disable_trading(reason: str) -> None
  enable_trading() -> None
  get_fills(order_id: Optional[str], symbol: Optional[str], days_back: int) -> List[TradeFill]
  get_open_orders(symbol: Optional[str]) -> List[OrderUpdate]
  get_order(order_id: str) -> Optional[OrderUpdate]
  get_order_history(symbol: Optional[str], days_back: int) -> List[OrderUpdate]
  is_trading_enabled() -> bool
  modify_order(order_id: str, new_quantity: Optional[float], new_limit_price: Optional[float], new_stop_price: Optional[float]) -> OrderResult
  set_fill_callback(callback: Optional[Callable[[TradeFill], None]]) -> None
  set_max_order_size(max_quantity: float) -> None
  set_max_position_size(symbol: str, max_quantity: float) -> None
  set_order_callback(callback: Optional[Callable[[OrderUpdate], None]]) -> None
  submit_bracket_order(entry: OrderRequest, take_profit: OrderRequest, stop_loss: OrderRequest) -> List[OrderResult]
  submit_order(request: OrderRequest) -> OrderResult
}
class "IbHistoricalAdapter" as apex.src.infrastructure.adapters.ib.historical_adapter.IbHistoricalAdapter {
  ADAPTER_TYPE : str
  ib : NoneType
  source_name : str
  fetch_bars(symbol: str, timeframe: str, start: Optional[datetime], end: Optional[datetime], limit: Optional[int]) -> List[BarData]
  fetch_bars_batch(requests: List[dict], max_concurrent: int, delay_between_batches: float) -> dict
  fetch_latest_bar(symbol: str, timeframe: str) -> Optional[BarData]
  fetch_option_chain_bars(underlying: str, expiry: str, timeframe: str, limit: int) -> Dict[str, List[BarData]]
  get_max_history_days(timeframe: str) -> int
  get_supported_timeframes() -> List[str]
  set_bar_callback(callback: Optional[Callable[[BarData], None]]) -> None
  subscribe_bars(symbol: str, timeframe: str) -> None
  supports_timeframe(timeframe: str) -> bool
  unsubscribe_bars(symbol: str, timeframe: str) -> None
}
class "IbLiveAdapter" as apex.src.infrastructure.adapters.ib.live_adapter.IbLiveAdapter {
  ADAPTER_TYPE : str
  ib : NoneType
  disable_streaming() -> None
  enable_streaming() -> None
  fetch_account() -> AccountSnapshot
  fetch_accounts() -> Dict[str, AccountSnapshot]
  fetch_market_data(positions: List[Position]) -> List[MarketData]
  fetch_market_indicators(symbols: List[str]) -> Dict[str, MarketData]
  fetch_position(symbol: str) -> Optional[PositionSnapshot]
  fetch_positions() -> List[PositionSnapshot]
  fetch_positions_by_underlying(underlying: str) -> List[PositionSnapshot]
  fetch_snapshot(symbols: List[str]) -> Dict[str, QuoteTick]
  get_account_id() -> Optional[str]
  get_all_quotes() -> Dict[str, QuoteTick]
  get_buying_power() -> float
  get_cached_account() -> Optional[AccountSnapshot]
  get_cached_positions() -> List[PositionSnapshot]
  get_latest(symbol: str) -> Optional[MarketData]
  get_latest_quote(symbol: str) -> Optional[QuoteTick]
  get_margin_utilization() -> float
  get_position_count() -> int
  get_positions_by_asset_type(asset_type: str) -> List[PositionSnapshot]
  get_subscribed_symbols() -> List[str]
  set_account_callback(callback: Optional[Callable[[AccountSnapshot], None]]) -> None
  set_position_callback(callback: Optional[Callable[[List[PositionSnapshot]], None]]) -> None
  set_quote_callback(callback: Optional[Callable[[QuoteTick], None]]) -> None
  subscribe_account() -> None
  subscribe_positions() -> None
  subscribe_quotes(symbols: List[str]) -> None
  {abstract}unsubscribe_account() -> None
  unsubscribe_positions() -> None
  unsubscribe_quotes(symbols: List[str]) -> None
}
class "MarketDataFetcher" as apex.src.infrastructure.adapters.market_data_fetcher.MarketDataFetcher {
  data_timeout : float
  ib : Any
  option_data_timeout : float
  poll_interval : float
  cleanup() -> None
  cleanup_async() -> None
  disable_streaming() -> None
  enable_streaming() -> None
  fetch_market_data(positions: List[Position], qualified_contracts: List, pos_map: Dict[int, Position]) -> List[MarketData]
  prune_stale_subscriptions(current_symbols: set[str]) -> int
  set_event_loop(loop: asyncio.AbstractEventLoop) -> None
  start_dispatch() -> None
  stop_dispatch() -> None
  unsubscribe_symbol(symbol: str) -> None
}
class "MarketDataManager" as apex.src.infrastructure.adapters.market_data_manager.MarketDataManager {
  DEFAULT_EVICTION_AGE_SECONDS : int
  DEFAULT_MAX_SYMBOLS : int
  check_all_health() -> Dict[str, MarketDataProviderStatus]
  connect() -> None
  disable_streaming() -> None
  disconnect() -> None
  enable_streaming() -> None
  fetch_market_data(positions: List[Position]) -> List[MarketData]
  fetch_quotes(symbols: List[str]) -> Dict[str, MarketData]
  get_all_status() -> Dict[str, MarketDataProviderStatus]
  get_latest(symbol: str) -> Optional[MarketData]
  get_provider(name: str) -> Optional[MarketDataProvider]
  get_providers_with_greeks() -> List[str]
  get_status(name: str) -> Optional[MarketDataProviderStatus]
  get_streaming_providers() -> List[str]
  is_connected() -> bool
  register_provider(name: str, provider: MarketDataProvider, priority: int) -> None
  set_health_monitor(health_monitor: 'HealthMonitor') -> None
  set_streaming_callback(callback: Optional[Callable[[str, MarketData], None]]) -> None
  subscribe(symbols: List[str]) -> None
  supports_greeks() -> bool
  supports_streaming() -> bool
  unsubscribe(symbols: List[str]) -> None
}
class "MarketDataProviderStatus" as apex.src.infrastructure.adapters.market_data_manager.MarketDataProviderStatus {
  connected : bool
  last_error : Optional[str]
  last_updated : datetime
  name : str
  supports_greeks : bool
  supports_streaming : bool
  symbols_fetched : int
}
class "OrderFetcher" as apex.src.infrastructure.adapters.futu.order_fetcher.OrderFetcher {
  fetch_orders(include_open: bool, include_completed: bool, days_back: int) -> List[Order]
  fetch_trades(days_back: int) -> List[Trade]
}
class "PositionFetcher" as apex.src.infrastructure.adapters.futu.position_fetcher.PositionFetcher {
  fetch() -> List[Position]
  get_cached() -> Optional[List[Position]]
  invalidate_cache() -> None
}
class "QualificationRequest" as apex.src.infrastructure.adapters.ib.contract_qualification_service.QualificationRequest {
  callback : Optional[Callable[[Any], Awaitable[None]]]
  contract : Any
  created_at : datetime
}
class "QualifiedContract" as apex.src.infrastructure.adapters.ib.contract_qualification_service.QualifiedContract {
  contract : Any
  is_expired : bool
  qualified_at : datetime
  ttl_hours : int
}
class "SignalIntrospectionAdapter" as apex.src.infrastructure.adapters.signal_introspection_adapter.SignalIntrospectionAdapter {
  get_all_cooldowns() -> List[Dict[str, Any]]
  get_all_warmup_status() -> List[Dict[str, Any]]
  get_cooldown_status(category: str, indicator: str, symbol: str, timeframe: str) -> Optional[Dict[str, Any]]
  get_indicator_state(symbol: str, timeframe: str, indicator: str) -> Optional[Dict[str, Any]]
  get_indicator_states(symbol: Optional[str], timeframe: Optional[str]) -> Dict[Tuple[str, str], Dict[str, Dict[str, Any]]]
  get_pipeline_stats() -> Dict[str, Any]
  get_recent_signals(limit: int) -> List[Dict[str, Any]]
  get_rule_evaluations(limit: int, triggered_only: bool) -> List[Dict[str, Any]]
  get_warmup_status(symbol: str, timeframe: str) -> Dict[str, Any]
  record_signal(signal: Dict[str, Any]) -> None
  start() -> None
}
class "TickerUpdate" as apex.src.infrastructure.adapters.market_data_fetcher.TickerUpdate {
  symbol : str
  ticker_id : int
  timestamp : float
}
class "YahooFinanceAdapter" as apex.src.infrastructure.adapters.yahoo.adapter.YahooFinanceAdapter {
  DEFAULT_BETA : float
  MAX_CONCURRENT_REQUESTS : int
  fetch_metrics : Dict[str, int]
  clear_cache(symbol: Optional[str]) -> None
  connect() -> None
  disconnect() -> None
  fetch_market_data(positions: List[Position]) -> List[MarketData]
  fetch_quotes(symbols: List[str]) -> Dict[str, MarketData]
  get_beta(symbol: str) -> float
  get_betas(symbols: List[str]) -> Dict[str, float]
  get_cache_stats() -> Dict[str, int]
  get_latest(symbol: str) -> Optional[MarketData]
  is_connected() -> bool
  prefetch_betas(symbols: List[str]) -> int
  {abstract}set_streaming_callback(callback: Optional[Callable[[str, MarketData], None]]) -> None
  subscribe(symbols: List[str]) -> None
  supports_greeks() -> bool
  supports_streaming() -> bool
  {abstract}unsubscribe(symbols: List[str]) -> None
}
class "YahooHistoricalAdapter" as apex.src.infrastructure.adapters.yahoo.historical_adapter.YahooHistoricalAdapter {
  MAX_HISTORY_DAYS : dict
  TIMEFRAME_MAP : dict
  source_name : str
  fetch_bars(symbol: str, timeframe: str, start: datetime, end: datetime) -> List[BarData]
  fetch_bars_batch(symbols: List[str], timeframe: str, start: datetime, end: datetime) -> dict[str, List[BarData]]
  get_max_history_days(timeframe: str) -> int
  get_supported_timeframes() -> List[str]
  supports_timeframe(timeframe: str) -> bool
}
apex.src.infrastructure.adapters.futu.exceptions.FutuAuthError --|> apex.src.infrastructure.adapters.futu.exceptions.FutuError
apex.src.infrastructure.adapters.futu.exceptions.FutuConnectionError --|> apex.src.infrastructure.adapters.futu.exceptions.FutuError
apex.src.infrastructure.adapters.futu.exceptions.FutuDataError --|> apex.src.infrastructure.adapters.futu.exceptions.FutuError
apex.src.infrastructure.adapters.futu.exceptions.FutuRateLimitError --|> apex.src.infrastructure.adapters.futu.exceptions.FutuError
apex.src.infrastructure.adapters.ib.execution_adapter.IbExecutionAdapter --|> apex.src.infrastructure.adapters.ib.base.IbBaseAdapter
apex.src.infrastructure.adapters.ib.historical_adapter.IbHistoricalAdapter --|> apex.src.infrastructure.adapters.ib.base.IbBaseAdapter
apex.src.infrastructure.adapters.ib.live_adapter.IbLiveAdapter --|> apex.src.infrastructure.adapters.ib.base.IbBaseAdapter
@enduml
