"""
JavaScript Generator - Embedded JavaScript for signal package.

Contains the app.js content with lazy loading and full chart rendering.
"""

from __future__ import annotations

import json
from typing import Dict, List


def build_javascript(
    symbols: List[str],
    timeframes: List[str],
    colors: Dict[str, str],
) -> str:
    """
    Build JavaScript content for app.js with lazy loading and full chart rendering.

    Args:
        symbols: List of symbol names
        timeframes: List of timeframe strings
        colors: Theme color dictionary

    Returns:
        Complete JavaScript content string
    """
    colors_json = json.dumps(colors)
    return f"""
// Signal Package JavaScript
// Generated by PackageBuilder - supports lazy loading with full chart rendering

const CONFIG = {{
    symbols: {json.dumps(symbols)},
    timeframes: {json.dumps(timeframes)},
    dataCache: {{}},
    summary: null,
    currentSymbol: '{symbols[0] if symbols else ''}',
    currentTimeframe: '1d',  // Default to daily timeframe
    signalLookbackBars: 24   // Only show signals from last N bars
}};

const colors = {colors_json};

function getDataKey() {{
    return `${{CONFIG.currentSymbol}}_${{CONFIG.currentTimeframe}}`;
}}

// Load summary on page load
async function loadSummary() {{
    try {{
        const response = await fetch('data/summary.json');
        CONFIG.summary = await response.json();
        console.log('Summary loaded:', CONFIG.summary.symbol_count, 'symbols');
        // Pass current symbol to ensure URL param is respected
        await updateChart(CONFIG.currentSymbol);
    }} catch (error) {{
        console.error('Failed to load summary:', error);
    }}
}}

// Lazy load data for a symbol/timeframe
async function loadData(symbol, timeframe) {{
    const key = `${{symbol}}_${{timeframe}}`;

    // Check cache first
    if (CONFIG.dataCache[key]) {{
        return CONFIG.dataCache[key];
    }}

    // Show loading state
    const chartEl = document.getElementById('main-chart');
    chartEl.classList.add('loading');
    chartEl.innerHTML = '<div class="loading-spinner">Loading data...</div>';

    try {{
        const response = await fetch(`data/${{key}}.json`);
        if (!response.ok) {{
            throw new Error(`Data not found for ${{key}}`);
        }}
        const data = await response.json();
        CONFIG.dataCache[key] = data;
        console.log(`Loaded ${{key}}: ${{data.bar_count}} bars`);
        return data;
    }} catch (error) {{
        console.error(`Failed to load ${{key}}:`, error);
        chartEl.innerHTML = '<div class="loading-error">Failed to load data for ' + key + '</div>';
        return null;
    }}
}}

// Update chart with current selection
async function updateChart(symbolOverride = null) {{
    // Use override if provided, otherwise read from select (for user interactions)
    const symbol = symbolOverride || document.getElementById('symbol-select').value;
    const timeframe = CONFIG.currentTimeframe;

    CONFIG.currentSymbol = symbol;

    // Sync select element with current symbol
    const selectEl = document.getElementById('symbol-select');
    if (selectEl && selectEl.value !== symbol) {{
        selectEl.value = symbol;
    }}

    const data = await loadData(symbol, timeframe);
    if (!data) return;

    renderMainChart(data);
    updateSignalHistoryTable();
    updateConfluencePanel();
    updateRegimeSection();
}}

// Render full multi-subplot chart using Plotly (matches SignalReportGenerator)
function renderMainChart(data) {{
    const chartEl = document.getElementById('main-chart');
    // Clear loading state
    chartEl.classList.remove('loading');
    chartEl.innerHTML = '';

    const chartData = data.chart_data;
    const traces = [];
    const hasData = (values) => values && values.length > 0 && !values.every(v => v === null);

    // Issue 4: Debug logging for indicator data
    console.log('=== Chart Data Debug ===');
    console.log('Timestamps count:', chartData.timestamps?.length || 0);
    console.log('OHLCV counts:', {{
        open: chartData.open?.length || 0,
        high: chartData.high?.length || 0,
        low: chartData.low?.length || 0,
        close: chartData.close?.length || 0,
        volume: chartData.volume?.length || 0
    }});
    console.log('Overlay indicators:', Object.keys(chartData.overlays || {{}}));
    console.log('RSI data keys:', Object.keys(chartData.rsi || {{}}));
    console.log('MACD data keys:', Object.keys(chartData.macd || {{}}));
    console.log('RSI values (first 5):', chartData.rsi?.rsi_rsi?.slice(0, 5));
    console.log('MACD values (first 5):', chartData.macd?.macd_macd?.slice(0, 5));
    console.log('Bollinger values (first 5):', chartData.overlays?.bollinger_bb_upper?.slice(0, 5));

    // For intraday charts, use index-based x-axis to avoid gaps
    const isIntraday = ['1m', '5m', '15m', '30m', '1h', '4h'].includes(data.timeframe);
    const xValues = isIntraday
        ? chartData.timestamps.map((_, i) => i)
        : chartData.timestamps;

    // Row 1: Price candlesticks
    traces.push({{
        type: 'candlestick',
        x: xValues,
        open: chartData.open,
        high: chartData.high,
        low: chartData.low,
        close: chartData.close,
        name: 'Price',
        increasing: {{ line: {{ color: colors.success }}, fillcolor: colors.success }},
        decreasing: {{ line: {{ color: colors.danger }}, fillcolor: colors.danger }},
        xaxis: 'x',
        yaxis: 'y',
    }});

    // Overlay indicators: Bollinger Bands, SuperTrend
    const overlayConfig = {{
        'bollinger_bb_upper': {{ color: '#3b82f6', dash: 'dot' }},
        'bollinger_bb_middle': {{ color: '#6366f1', dash: 'solid' }},
        'bollinger_bb_lower': {{ color: '#3b82f6', dash: 'dot' }},
        'supertrend_supertrend': {{ color: '#f59e0b', dash: 'solid' }},
    }};
    for (const [name, config] of Object.entries(overlayConfig)) {{
        const values = chartData.overlays[name];
        if (!hasData(values)) continue;
        traces.push({{
            type: 'scatter',
            mode: 'lines',
            x: xValues,
            y: values,
            name: name.replace('bollinger_bb_', 'BB ').replace('supertrend_', 'ST '),
            line: {{ color: config.color, width: 1, dash: config.dash }},
            xaxis: 'x',
            yaxis: 'y',
        }});
    }}

    // Row 2: RSI with threshold lines
    const rsiValues = chartData.rsi['rsi_rsi'];
    if (hasData(rsiValues)) {{
        traces.push({{
            type: 'scatter',
            mode: 'lines',
            x: xValues,
            y: rsiValues,
            name: 'RSI',
            line: {{ color: '#8b5cf6', width: 1.5 }},
            xaxis: 'x',
            yaxis: 'y2',
        }});
        const boundsX = [xValues[0], xValues[xValues.length - 1]];
        const rsiLevels = [
            {{ value: 70, name: 'Overbought', color: colors.danger }},
            {{ value: 30, name: 'Oversold', color: colors.success }},
        ];
        for (const level of rsiLevels) {{
            traces.push({{
                type: 'scatter',
                mode: 'lines',
                x: boundsX,
                y: [level.value, level.value],
                name: level.name,
                line: {{ color: level.color, width: 1, dash: 'dash' }},
                xaxis: 'x',
                yaxis: 'y2',
                showlegend: false,
            }});
        }}
    }}

    // Row 3: MACD subplot (DualMACD if available, else standard MACD)
    const hasDualMACD = chartData.dual_macd && (
        hasData(chartData.dual_macd['dual_macd_long_histogram']) ||
        hasData(chartData.dual_macd['dual_macd_short_histogram'])
    );

    if (hasDualMACD) {{
        // DualMACD: Overlay long (55/89) and short (13/21) histograms
        const longHist = chartData.dual_macd['dual_macd_long_histogram'];
        const shortHist = chartData.dual_macd['dual_macd_short_histogram'];

        // Long MACD histogram (trend direction) - wider bars, more transparent
        if (hasData(longHist)) {{
            const longColors = longHist.map(v => v >= 0 ? 'rgba(16, 185, 129, 0.4)' : 'rgba(239, 68, 68, 0.4)');
            traces.push({{
                type: 'bar',
                x: xValues,
                y: longHist,
                name: 'Long MACD (55/89)',
                marker: {{ color: longColors }},
                xaxis: 'x',
                yaxis: 'y3',
                width: isIntraday ? 0.8 : 86400000 * 0.8,
            }});
        }}

        // Short MACD histogram (momentum timing) - narrower bars, more opaque
        if (hasData(shortHist)) {{
            const shortColors = shortHist.map(v => v >= 0 ? 'rgba(59, 130, 246, 0.8)' : 'rgba(249, 115, 22, 0.8)');
            traces.push({{
                type: 'bar',
                x: xValues,
                y: shortHist,
                name: 'Short MACD (13/21)',
                marker: {{ color: shortColors }},
                xaxis: 'x',
                yaxis: 'y3',
                width: isIntraday ? 0.4 : 86400000 * 0.4,
            }});
        }}

        // Add zero line for reference
        traces.push({{
            type: 'scatter',
            mode: 'lines',
            x: [xValues[0], xValues[xValues.length - 1]],
            y: [0, 0],
            name: 'Zero',
            line: {{ color: colors.text_muted, width: 1, dash: 'dot' }},
            xaxis: 'x',
            yaxis: 'y3',
            showlegend: false,
        }});
    }} else {{
        // Standard MACD fallback
        const macdHist = chartData.macd['macd_histogram'];
        if (hasData(macdHist)) {{
            const barColors = macdHist.map(v => v >= 0 ? colors.success : colors.danger);
            traces.push({{
                type: 'bar',
                x: xValues,
                y: macdHist,
                name: 'MACD Hist',
                marker: {{ color: barColors }},
                xaxis: 'x',
                yaxis: 'y3',
            }});
        }}
        const macdLines = [
            {{ key: 'macd_macd', name: 'MACD', color: '#3b82f6' }},
            {{ key: 'macd_signal', name: 'Signal', color: '#f59e0b' }},
        ];
        for (const {{ key, name, color }} of macdLines) {{
            const values = chartData.macd[key];
            if (!hasData(values)) continue;
            traces.push({{
                type: 'scatter',
                mode: 'lines',
                x: xValues,
                y: values,
                name,
                line: {{ color, width: 1.5 }},
                xaxis: 'x',
                yaxis: 'y3',
            }});
        }}
    }}

    // Row 4: Volume bars
    if (chartData.volume && chartData.volume.length > 0) {{
        const volColors = chartData.close.map((c, i) => {{
            if (i === 0) return colors.text_muted;
            return c >= chartData.close[i-1] ? colors.success : colors.danger;
        }});
        traces.push({{
            type: 'bar',
            x: xValues,
            y: chartData.volume,
            name: 'Volume',
            marker: {{ color: volColors, opacity: 0.5 }},
            xaxis: 'x',
            yaxis: 'y4',
        }});
    }}

    // Add signal markers on price chart
    const key = getDataKey();
    const signals = data.signals || [];
    const buySignals = signals.filter(s => s.direction === 'buy');
    const sellSignals = signals.filter(s => s.direction === 'sell');

    if (buySignals.length > 0) {{
        const buyData = buySignals.map(s => {{
            const idx = chartData.timestamps.findIndex(t => t === s.timestamp);
            if (idx < 0) return null;
            return {{
                x: isIntraday ? idx : s.timestamp,
                y: chartData.low[idx] * 0.995,
                rule: s.rule
            }};
        }}).filter(d => d !== null);

        if (buyData.length > 0) {{
            traces.push({{
                type: 'scatter',
                mode: 'markers',
                x: buyData.map(d => d.x),
                y: buyData.map(d => d.y),
                name: 'Buy Signal',
                marker: {{
                    symbol: 'triangle-up',
                    size: 12,
                    color: colors.success,
                    line: {{ color: 'white', width: 1 }}
                }},
                hovertemplate: '%{{text}}<extra></extra>',
                text: buyData.map(d => d.rule),
                xaxis: 'x',
                yaxis: 'y',
            }});
        }}
    }}

    if (sellSignals.length > 0) {{
        const sellData = sellSignals.map(s => {{
            const idx = chartData.timestamps.findIndex(t => t === s.timestamp);
            if (idx < 0) return null;
            return {{
                x: isIntraday ? idx : s.timestamp,
                y: chartData.high[idx] * 1.005,
                rule: s.rule
            }};
        }}).filter(d => d !== null);

        if (sellData.length > 0) {{
            traces.push({{
                type: 'scatter',
                mode: 'markers',
                x: sellData.map(d => d.x),
                y: sellData.map(d => d.y),
                name: 'Sell Signal',
                marker: {{
                    symbol: 'triangle-down',
                    size: 12,
                    color: colors.danger,
                    line: {{ color: 'white', width: 1 }}
                }},
                hovertemplate: '%{{text}}<extra></extra>',
                text: sellData.map(d => d.rule),
                xaxis: 'x',
                yaxis: 'y',
            }});
        }}
    }}

    // Layout with 4 subplots
    const isDaily = ['1d', '1w', '1D', '1W'].includes(data.timeframe);
    let rangebreaks = [];
    if (isDaily) {{
        rangebreaks = [{{ bounds: ['sat', 'mon'] }}];
    }}

    // Custom tick labels for intraday
    let tickvals = null;
    let ticktext = null;
    if (isIntraday && chartData.timestamps.length > 0) {{
        const n = chartData.timestamps.length;
        const step = Math.max(1, Math.floor(n / 15));
        tickvals = [];
        ticktext = [];
        for (let i = 0; i < n; i += step) {{
            tickvals.push(i);
            const ts = new Date(chartData.timestamps[i]);
            const month = String(ts.getUTCMonth() + 1).padStart(2, '0');
            const day = String(ts.getUTCDate()).padStart(2, '0');
            const hour = String(ts.getUTCHours()).padStart(2, '0');
            const min = String(ts.getUTCMinutes()).padStart(2, '0');
            ticktext.push(`${{month}}/${{day}} ${{hour}}:${{min}}`);
        }}
    }}

    const layout = {{
        title: {{
            text: `${{data.symbol}} - ${{data.timeframe}} (${{data.bar_count}} bars)`,
            font: {{ color: colors.text, size: 18 }},
        }},
        showlegend: true,
        legend: {{
            orientation: 'h',
            y: -0.08,
            font: {{ color: colors.text, size: 10 }},
        }},
        paper_bgcolor: colors.card_bg,
        plot_bgcolor: colors.card_bg,
        font: {{ color: colors.text }},
        margin: {{ t: 50, r: 50, b: 80, l: 50 }},
        hovermode: 'x unified',
        bargap: 0.1,
        barmode: 'overlay',  // DualMACD: overlay long and short histograms

        xaxis: {{
            title: {{ text: 'Time (UTC)', standoff: 10, font: {{ size: 11, color: colors.text_muted }} }},
            gridcolor: colors.border,
            showgrid: true,
            rangeslider: {{ visible: false }},
            tickangle: -45,
            domain: [0, 1],
            rangebreaks: rangebreaks,
            ...(isIntraday && tickvals ? {{ tickvals: tickvals, ticktext: ticktext }} : {{ nticks: 15 }}),
        }},

        // Y1: Price (48% with gap) - CRITICAL: autorange: true
        yaxis: {{
            title: 'Price',
            side: 'right',
            gridcolor: colors.border,
            showgrid: true,
            domain: [0.52, 1.00],
            autorange: true,
        }},

        // Y2: RSI (12% with gap)
        yaxis2: {{
            title: 'RSI',
            side: 'right',
            gridcolor: colors.border,
            showgrid: true,
            domain: [0.36, 0.48],
            range: [0, 100],
            dtick: 25,
        }},

        // Y3: MACD (12% with gap)
        yaxis3: {{
            title: hasDualMACD ? 'DualMACD (55/89 + 13/21)' : 'MACD',
            side: 'right',
            gridcolor: colors.border,
            showgrid: true,
            domain: [0.20, 0.32],
        }},

        // Y4: Volume (16%)
        yaxis4: {{
            title: 'Vol',
            side: 'right',
            gridcolor: colors.border,
            showgrid: true,
            domain: [0.00, 0.16],
        }},
    }};

    const config = {{
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
    }};

    Plotly.newPlot('main-chart', traces, layout, config);
}}

// Update signal history table - simplified to show only full history
// Active signals and price levels now shown in Confluence Analysis
function updateSignalHistoryTable() {{
    const key = getDataKey();
    const cachedData = CONFIG.dataCache[key];
    const container = document.getElementById('signals-content');
    if (!container) return;

    const allSignals = cachedData ? cachedData.signals || [] : [];

    if (allSignals.length === 0) {{
        container.innerHTML = '<div class="no-signals">No signals for this symbol/timeframe</div>';
        return;
    }}

    // ========== Full Signal History (Collapsible) ==========
    const sortedAll = [...allSignals].sort((a, b) =>
        new Date(b.timestamp) - new Date(a.timestamp)
    );

    let html = `
            <div style="margin-top: 24px;">
                <h4 class="collapsible-header" onclick="toggleHistoryTable()" style="cursor: pointer; margin-bottom: 12px; color: ${{colors.text_muted}}; font-size: 12px; text-transform: uppercase;">
                    <span id="history-toggle-icon">▶</span> Full Signal History (${{allSignals.length}} signals) - Click to expand
                </h4>
                <div id="full-history-table" style="display: none;">
                    <table class="signal-table">
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Signal</th>
                                <th>Direction</th>
                                <th>Indicator</th>
                                <th>Message</th>
                            </tr>
                        </thead>
                        <tbody>
        `;

        for (const sig of sortedAll.slice(0, 100)) {{
            const time = new Date(sig.timestamp).toLocaleString();
            const direction = sig.direction || 'alert';
            html += `
                <tr>
                    <td>${{time}}</td>
                    <td>${{sig.rule}}</td>
                    <td><span class="signal-badge ${{direction}}">${{direction}}</span></td>
                    <td>${{sig.indicator}}</td>
                    <td>${{sig.message || '-'}}</td>
                </tr>
            `;
        }}
        if (allSignals.length > 100) {{
            html += `<tr><td colspan="5" style="text-align: center; color: ${{colors.text_muted}};">... and ${{allSignals.length - 100}} more signals</td></tr>`;
        }}

    html += '</tbody></table></div></div>';

    container.innerHTML = html;
}}

// Toggle full history table visibility
function toggleHistoryTable() {{
    const table = document.getElementById('full-history-table');
    const icon = document.getElementById('history-toggle-icon');
    if (table && icon) {{
        if (table.style.display === 'none') {{
            table.style.display = 'block';
            icon.textContent = '▼';
        }} else {{
            table.style.display = 'none';
            icon.textContent = '▶';
        }}
    }}
}}

// Update confluence panel - enhanced with active signals and price levels
function updateConfluencePanel() {{
    const key = getDataKey();
    const container = document.getElementById('confluence-content');
    if (!container || !CONFIG.summary) return;

    const confluence = CONFIG.summary.confluence ? CONFIG.summary.confluence[key] : null;

    // Get active signals and price levels data (moved from Signal History)
    const cachedData = CONFIG.dataCache[key];
    const allSignals = cachedData ? cachedData.signals || [] : [];
    const chartData = cachedData ? cachedData.chart_data || {{}} : {{}};
    const priceLevels = chartData.price_levels || {{}};
    const lastClose = chartData.close && chartData.close.length > 0
        ? chartData.close[chartData.close.length - 1]
        : null;

    if (!confluence) {{
        container.innerHTML = '<div class="no-confluence">No confluence data available for this symbol/timeframe</div>';
        return;
    }}

    const alignmentPct = (confluence.alignment_score + 100) / 2;
    const alignmentClass = confluence.alignment_score > 20 ? 'bullish' : confluence.alignment_score < -20 ? 'bearish' : 'neutral';

    // ========== Build Active Signals HTML ==========
    let activeSignalsHtml = '';
    if (allSignals.length > 0) {{
        const activeByIndicator = {{}};
        const sortedByTime = [...allSignals].sort((a, b) =>
            new Date(a.timestamp) - new Date(b.timestamp)
        );
        for (const sig of sortedByTime) {{
            activeByIndicator[sig.indicator || 'unknown'] = sig;
        }}
        const signals = Object.values(activeByIndicator);
        const buyCount = signals.filter(s => s.direction === 'buy').length;
        const sellCount = signals.filter(s => s.direction === 'sell').length;
        const neutralCount = signals.length - buyCount - sellCount;

        const sortedActiveSignals = [...signals].sort((a, b) =>
            (a.indicator || '').localeCompare(b.indicator || '')
        );

        let signalBarsHtml = sortedActiveSignals.slice(0, 8).map(sig => {{
            const direction = sig.direction || 'alert';
            const barColor = direction === 'buy' ? colors.success : direction === 'sell' ? colors.danger : colors.text_muted;
            return `
                <div style="display: flex; justify-content: space-between; padding: 3px 0; font-size: 11px;">
                    <span style="color: ${{colors.text_muted}};">${{sig.indicator}}</span>
                    <span style="color: ${{barColor}};">${{sig.rule}}</span>
                </div>
            `;
        }}).join('');

        if (signals.length > 8) {{
            signalBarsHtml += `<div style="color: ${{colors.text_muted}}; font-size: 10px; text-align: center; margin-top: 4px;">+${{signals.length - 8}} more</div>`;
        }}

        activeSignalsHtml = `
            <div style="background: ${{colors.card_bg}}; padding: 12px; border-radius: 8px; border: 1px solid ${{colors.border}};">
                <h4 style="margin: 0 0 8px 0; color: ${{colors.text}}; font-size: 12px; font-weight: 600;">
                    Active Signals - ${{CONFIG.currentTimeframe.toUpperCase()}}
                </h4>
                <div style="display: flex; gap: 12px; margin-bottom: 8px; font-size: 12px;">
                    <span style="color: ${{colors.success}};">▲ ${{buyCount}} Bullish</span>
                    <span style="color: ${{colors.danger}};">▼ ${{sellCount}} Bearish</span>
                    <span style="color: ${{colors.text_muted}};">● ${{neutralCount}} Neutral</span>
                </div>
                <div class="signal-bars">
                    ${{signalBarsHtml}}
                </div>
            </div>
        `;
    }}

    // ========== Build Price Levels HTML ==========
    let priceLevelsHtml = '';
    const hasLevels = Object.keys(priceLevels).length > 0;
    if (hasLevels && lastClose) {{
        const levelGroups = {{}};
        for (const [col, values] of Object.entries(priceLevels)) {{
            if (!values || values.length === 0) continue;
            const lastVal = values[values.length - 1];
            if (lastVal === null || lastVal === undefined) continue;

            const parts = col.split('_');
            const ind = parts[0].toUpperCase();
            const level = parts.slice(1).join('_').toUpperCase();

            if (!levelGroups[ind]) levelGroups[ind] = [];
            levelGroups[ind].push({{ level, value: lastVal }});
        }}

        let levelCardsHtml = '';
        for (const [ind, levels] of Object.entries(levelGroups)) {{
            levels.sort((a, b) => b.value - a.value);

            let indName = ind;
            if (ind === 'FIB') indName = 'Fibonacci';
            else if (ind === 'SR') indName = 'Support/Res';
            else if (ind === 'PIVOT') indName = 'Pivot Points';

            let levelRowsHtml = levels.slice(0, 3).map(({{ level, value }}) => {{
                const diff = ((value - lastClose) / lastClose * 100).toFixed(2);
                const isAbove = value > lastClose;
                const levelColor = isAbove ? colors.danger : colors.success;
                const arrow = isAbove ? '↑' : '↓';
                return `
                    <div style="display: flex; justify-content: space-between; font-size: 11px; padding: 2px 0;">
                        <span style="color: ${{colors.text_muted}};">${{level.replace(/_/g, ' ')}}</span>
                        <span>$${{value.toFixed(2)}} <span style="color: ${{levelColor}};">${{arrow}}${{Math.abs(diff)}}%</span></span>
                    </div>
                `;
            }}).join('');

            levelCardsHtml += `
                <div style="background: ${{colors.card_bg}}; padding: 10px; border-radius: 6px; border: 1px solid ${{colors.border}}; min-width: 140px;">
                    <div style="font-weight: 600; margin-bottom: 6px; font-size: 11px; color: ${{colors.text}};">${{indName}}</div>
                    ${{levelRowsHtml}}
                </div>
            `;
        }}

        priceLevelsHtml = `
            <div style="margin-top: 16px;">
                <h4 style="margin: 0 0 10px 0; color: ${{colors.text_muted}}; font-size: 11px; text-transform: uppercase;">
                    Key Price Levels ($${{lastClose.toFixed(2)}})
                </h4>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    ${{levelCardsHtml}}
                </div>
            </div>
        `;
    }}

    // ========== Build Divergence HTML ==========
    let divergenceHtml = '';
    if (confluence.diverging_pairs && confluence.diverging_pairs.length > 0) {{
        divergenceHtml = confluence.diverging_pairs.slice(0, 5).map(p => `
            <div class="divergence-item">
                <div class="indicators">${{p.ind1}} - ${{p.ind2}}</div>
                <div class="reason">${{p.reason}}</div>
            </div>
        `).join('');
    }} else {{
        divergenceHtml = '<div class="no-divergences">No divergences detected - indicators are aligned</div>';
    }}

    // ========== Render Enhanced 2-Column Layout ==========
    container.innerHTML = `
        <div class="confluence-panel-enhanced">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 16px;">
                <div class="alignment-column">
                    <div class="alignment-meter">
                        <div class="alignment-bar">
                            <div class="alignment-indicator" style="left: ${{alignmentPct}}%"></div>
                        </div>
                    </div>
                    <div class="alignment-value ${{alignmentClass}}" style="text-align: center; font-size: 24px; font-weight: bold; margin: 8px 0;">
                        ${{confluence.alignment_score > 0 ? '+' : ''}}${{Math.round(confluence.alignment_score)}}
                    </div>
                    <div class="signal-counts" style="display: flex; justify-content: center; gap: 16px;">
                        <div style="text-align: center;">
                            <div class="count-value bullish" style="font-size: 16px;">&#9650; ${{confluence.bullish_count}}</div>
                            <div style="font-size: 10px; color: ${{colors.text_muted}};">Bullish</div>
                        </div>
                        <div style="text-align: center;">
                            <div class="count-value neutral" style="font-size: 16px;">&#9679; ${{confluence.neutral_count}}</div>
                            <div style="font-size: 10px; color: ${{colors.text_muted}};">Neutral</div>
                        </div>
                        <div style="text-align: center;">
                            <div class="count-value bearish" style="font-size: 16px;">&#9660; ${{confluence.bearish_count}}</div>
                            <div style="font-size: 10px; color: ${{colors.text_muted}};">Bearish</div>
                        </div>
                    </div>
                </div>
                <div class="active-signals-column">
                    ${{activeSignalsHtml}}
                </div>
            </div>
            ${{priceLevelsHtml}}
            <div style="margin-top: 16px;">
                <h4 style="margin: 0 0 12px 0; color: ${{colors.text_muted}}; font-size: 11px; text-transform: uppercase;">Diverging Indicators</h4>
                ${{divergenceHtml}}
            </div>
        </div>
    `;
}}

// Regime HTML cache
const regimeHtmlCache = {{}};

// Update regime section - Load pre-rendered HTML for 1:1 feature parity
async function updateRegimeSection() {{
    const container = document.getElementById('regime-content');
    if (!container) return;

    const symbol = CONFIG.currentSymbol;
    const timeframe = CONFIG.currentTimeframe;
    const cacheKey = `${{symbol}}_${{timeframe}}`;

    // Check cache first
    if (regimeHtmlCache[cacheKey]) {{
        container.innerHTML = regimeHtmlCache[cacheKey];
        return;
    }}

    // Show loading state
    container.innerHTML = '<div class="no-regime">Loading regime analysis...</div>';

    // Try timeframe-specific file first, then fall back to symbol-only
    const urls = [
        `data/regime/${{symbol}}_${{timeframe}}.html`,
        `data/regime/${{symbol}}.html`
    ];

    for (const url of urls) {{
        try {{
            const response = await fetch(url);
            if (response.ok) {{
                const html = await response.text();
                regimeHtmlCache[cacheKey] = html;
                container.innerHTML = html;
                console.log(`Loaded regime HTML from ${{url}}`);
                return;
            }}
        }} catch (error) {{
            console.debug(`Failed to load ${{url}}:`, error);
        }}
    }}

    // Fall back to summary data if no pre-rendered HTML
    console.warn(`No regime HTML found for ${{cacheKey}}, using fallback`);
    fallbackRegimeSection(container, symbol);
}}

// Fallback: render basic regime info from summary data
function fallbackRegimeSection(container, symbol) {{
    if (!CONFIG.summary) {{
        container.innerHTML = '<div class="no-regime">No regime data available for ' + symbol + '</div>';
        return;
    }}

    const tickers = CONFIG.summary.tickers || [];
    const ticker = tickers.find(t => t.symbol === symbol);

    if (!ticker || !ticker.regime) {{
        container.innerHTML = '<div class="no-regime">No regime data available for ' + symbol + '</div>';
        return;
    }}

    const regimeColors = {{
        'R0': colors.success,
        'R1': colors.warning,
        'R2': colors.danger,
        'R3': colors.primary,
    }};
    const regimeNames = {{
        'R0': 'Healthy Uptrend',
        'R1': 'Choppy/Extended',
        'R2': 'Risk-Off',
        'R3': 'Rebound Window',
    }};
    const regimeColor = regimeColors[ticker.regime] || colors.text_muted;

    const components = ticker.component_states || {{}};
    const cv = ticker.component_values || {{}};
    const transition = ticker.transition || {{}};
    const quality = ticker.quality || {{}};

    const stateColors = {{
        'trend_up': colors.success, 'trend_down': colors.danger, 'neutral': colors.text_muted,
        'vol_high': colors.danger, 'vol_normal': colors.text_muted, 'vol_low': colors.success,
        'choppy': colors.warning, 'trending': colors.success,
        'overbought': colors.danger, 'oversold': colors.success, 'slightly_high': colors.warning, 'slightly_low': colors.primary,
    }};

    const formatState = (state) => {{
        const color = stateColors[state] || colors.text_muted;
        return `<span style="color: ${{color}}; font-weight: 500;">${{state ? state.toUpperCase().replace('_', ' ') : 'N/A'}}</span>`;
    }};

    container.innerHTML = `
        <div class="regime-dashboard">
            <div class="regime-header">
                <div class="regime-badge" style="background: ${{regimeColor}}20; color: ${{regimeColor}}; border: 2px solid ${{regimeColor}}; padding: 12px 24px; border-radius: 12px; font-size: 24px; font-weight: 700;">
                    ${{ticker.regime}}
                </div>
                <div style="flex: 1;">
                    <div class="regime-name" style="font-size: 18px; font-weight: 600;">${{ticker.regime_name || regimeNames[ticker.regime] || 'Unknown'}}</div>
                    <div class="regime-confidence" style="color: ${{colors.text_muted}};">Confidence: ${{ticker.confidence || 0}}%</div>
                </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px;">
                <div class="regime-components" style="background: ${{colors.bg}}; border-radius: 8px; padding: 16px;">
                    <h4 style="margin: 0 0 12px 0; color: ${{colors.text_muted}}; font-size: 12px; text-transform: uppercase;">Component States</h4>
                    <div class="component-row" style="display: flex; justify-content: space-between; padding: 6px 0;">
                        <span class="component-label">Trend:</span>
                        ${{formatState(components.trend_state)}}
                    </div>
                    <div class="component-row" style="display: flex; justify-content: space-between; padding: 6px 0;">
                        <span class="component-label">Volatility:</span>
                        ${{formatState(components.vol_state)}}
                    </div>
                    <div class="component-row" style="display: flex; justify-content: space-between; padding: 6px 0;">
                        <span class="component-label">Choppiness:</span>
                        ${{formatState(components.chop_state)}}
                    </div>
                    <div class="component-row" style="display: flex; justify-content: space-between; padding: 6px 0;">
                        <span class="component-label">Extension:</span>
                        ${{formatState(components.ext_state)}}
                    </div>
                </div>
                <div class="regime-metrics" style="background: ${{colors.bg}}; border-radius: 8px; padding: 16px;">
                    <h4 style="margin: 0 0 12px 0; color: ${{colors.text_muted}}; font-size: 12px; text-transform: uppercase;">Key Metrics</h4>
                    <div class="metric-row" style="display: flex; justify-content: space-between; padding: 6px 0;">
                        <span class="metric-label">Close:</span>
                        <span class="metric-value" style="font-weight: 500;">${{cv.close ? '$' + cv.close.toFixed(2) : 'N/A'}}</span>
                    </div>
                    <div class="metric-row" style="display: flex; justify-content: space-between; padding: 6px 0;">
                        <span class="metric-label">MA50:</span>
                        <span class="metric-value">${{cv.ma50 ? '$' + cv.ma50.toFixed(2) : 'N/A'}}</span>
                    </div>
                </div>
            </div>
            <p style="margin-top: 16px; color: ${{colors.text_muted}}; font-size: 12px;">
                <em>Note: Full regime analysis not available. Showing summary data.</em>
            </p>
        </div>
    `;
}}

// Set timeframe
function setTimeframe(tf) {{
    CONFIG.currentTimeframe = tf;

    // Update button states
    document.querySelectorAll('.tf-btn').forEach(btn => {{
        btn.classList.toggle('active', btn.dataset.tf === tf);
    }});

    updateChart();
}}

// Toggle section visibility - handles both string ID and DOM element (for regime report sections)
function toggleSection(arg) {{
    if (typeof arg === 'string') {{
        // Original behavior: arg is content ID
        const content = document.getElementById(arg);
        if (!content) return;
        const header = content.previousElementSibling;
        const icon = header ? header.querySelector('.toggle-icon') : null;

        content.classList.toggle('collapsed');
        if (icon) {{
            icon.style.transform = content.classList.contains('collapsed') ? 'rotate(-90deg)' : 'rotate(0deg)';
        }}
    }} else {{
        // New behavior: arg is the header element (from onclick="toggleSection(this)")
        const header = arg;
        const section = header.parentElement;
        if (!section || !section.classList.contains('report-section')) return;

        section.classList.toggle('collapsed');
        const indicator = header.querySelector('.collapse-indicator');
        if (indicator) {{
            indicator.textContent = section.classList.contains('collapsed') ? '\u25b6' : '\u25bc';
        }}
    }}
}}

// Load and render indicators section
async function loadIndicatorsSection() {{
    const container = document.getElementById('indicators-content');
    if (!container) return;

    try {{
        const response = await fetch('data/indicators.json');
        if (!response.ok) {{
            container.innerHTML = '<div class="no-indicators">Indicators data not available</div>';
            return;
        }}
        const data = await response.json();
        renderIndicatorsSection(container, data);
    }} catch (error) {{
        console.error('Failed to load indicators:', error);
        container.innerHTML = '<div class="no-indicators">Failed to load indicators</div>';
    }}
}}

function renderIndicatorsSection(container, data) {{
    if (!data.categories || data.categories.length === 0) {{
        container.innerHTML = '<div class="no-indicators">No indicators configured</div>';
        return;
    }}

    let html = '';
    for (const category of data.categories) {{
        html += `
            <div class="category-group">
                <div class="category-title">${{category.name}}</div>
                <div class="indicator-cards">
        `;

        for (const ind of category.indicators) {{
            const paramsStr = Object.entries(ind.params || {{}})
                .map(([k, v]) => `${{k}}=${{v}}`)
                .join(', ');

            let rulesHtml = '';
            if (ind.rules && ind.rules.length > 0) {{
                rulesHtml = '<div class="rules"><h4>Rules</h4>';
                for (const rule of ind.rules) {{
                    rulesHtml += `
                        <div class="rule-item">
                            <span class="rule-name direction-${{rule.direction}}">${{rule.id}}</span>
                            <div class="rule-desc">${{rule.description}}</div>
                        </div>
                    `;
                }}
                rulesHtml += '</div>';
            }}

            html += `
                <div class="indicator-card">
                    <h3>${{ind.name}}</h3>
                    <div class="description">${{ind.description}}${{paramsStr ? '. Params: ' + paramsStr : ''}}</div>
                    ${{rulesHtml}}
                </div>
            `;
        }}

        html += '</div></div>';
    }}

    container.innerHTML = html;
}}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {{
    // Parse URL query parameters to set initial symbol (e.g., ?symbol=NVDA)
    const urlParams = new URLSearchParams(window.location.search);
    const symbolParam = urlParams.get('symbol');
    if (symbolParam && CONFIG.symbols.includes(symbolParam)) {{
        CONFIG.currentSymbol = symbolParam;
        const selectEl = document.getElementById('symbol-select');
        if (selectEl) selectEl.value = symbolParam;
    }}

    loadSummary();
    loadIndicatorsSection();

    // Set initial timeframe button
    const initialTf = CONFIG.currentTimeframe;
    document.querySelectorAll('.tf-btn').forEach(btn => {{
        btn.classList.toggle('active', btn.dataset.tf === initialTf);
    }});
}});
"""
