"""
Repository for risk and trade signals persistence.

Handles persistence of signals generated by the risk engine and trading strategies.
Uses flexible JSONB payload for extensibility.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional

from asyncpg import Record

from src.infrastructure.persistence.database import Database
from src.infrastructure.persistence.repositories.base import BaseRepository

logger = logging.getLogger(__name__)


@dataclass
class RiskSignal:
    """Risk signal entity."""

    signal_time: datetime
    signal_type: str  # BREACH, WARNING, INFO
    signal_name: str  # 'delta_limit', 'concentration', etc.
    severity: Optional[str]  # SOFT, HARD, CRITICAL
    symbol: Optional[str]
    underlying: Optional[str]
    payload: Dict[str, Any]
    snapshot_id: Optional[int] = None
    created_at: Optional[datetime] = None
    id: Optional[int] = None


@dataclass
class TradeSignal:
    """Trade signal entity."""

    signal_time: datetime
    signal_source: str  # Strategy name
    signal_type: str  # ENTRY, EXIT, SCALE, HEDGE
    symbol: Optional[str]
    underlying: Optional[str]
    direction: Optional[str]  # LONG, SHORT, CLOSE
    confidence: Optional[Decimal]
    payload: Dict[str, Any]
    executed: bool = False
    execution_time: Optional[datetime] = None
    execution_order_id: Optional[str] = None
    created_at: Optional[datetime] = None
    id: Optional[int] = None


class RiskSignalRepository(BaseRepository[RiskSignal]):
    """Repository for risk signals."""

    def __init__(self, db: Database):
        super().__init__(db)

    @property
    def table_name(self) -> str:
        return "risk_signals"

    def _to_entity(self, record: Record) -> RiskSignal:
        """Convert database record to RiskSignal entity."""
        return RiskSignal(
            id=record["id"],
            signal_time=record["signal_time"],
            signal_type=record["signal_type"],
            signal_name=record["signal_name"],
            severity=record["severity"],
            symbol=record["symbol"],
            underlying=record["underlying"],
            payload=self._from_json(record["payload"]),
            snapshot_id=record["snapshot_id"],
            created_at=record["created_at"],
        )

    def _to_row(self, entity: RiskSignal) -> Dict[str, Any]:
        """Convert RiskSignal entity to database row."""
        return {
            "signal_time": entity.signal_time,
            "signal_type": entity.signal_type,
            "signal_name": entity.signal_name,
            "severity": entity.severity,
            "symbol": entity.symbol,
            "underlying": entity.underlying,
            "payload": self._to_json(entity.payload),
            "snapshot_id": entity.snapshot_id,
        }

    async def find_by_type(
        self,
        signal_type: str,
        since: Optional[datetime] = None,
        limit: int = 100,
    ) -> List[RiskSignal]:
        """Find signals by type."""
        if since:
            query = """
                SELECT * FROM risk_signals
                WHERE signal_type = $1 AND signal_time >= $2
                ORDER BY signal_time DESC
                LIMIT $3
            """
            records = await self._db.fetch(query, signal_type, since, limit)
        else:
            query = """
                SELECT * FROM risk_signals
                WHERE signal_type = $1
                ORDER BY signal_time DESC
                LIMIT $2
            """
            records = await self._db.fetch(query, signal_type, limit)

        return [self._to_entity(r) for r in records]

    async def find_by_name(
        self,
        signal_name: str,
        since: Optional[datetime] = None,
        limit: int = 100,
    ) -> List[RiskSignal]:
        """Find signals by name."""
        if since:
            query = """
                SELECT * FROM risk_signals
                WHERE signal_name = $1 AND signal_time >= $2
                ORDER BY signal_time DESC
                LIMIT $3
            """
            records = await self._db.fetch(query, signal_name, since, limit)
        else:
            query = """
                SELECT * FROM risk_signals
                WHERE signal_name = $1
                ORDER BY signal_time DESC
                LIMIT $2
            """
            records = await self._db.fetch(query, signal_name, limit)

        return [self._to_entity(r) for r in records]

    async def find_by_symbol(
        self,
        symbol: str,
        since: Optional[datetime] = None,
        limit: int = 100,
    ) -> List[RiskSignal]:
        """Find signals for a specific symbol."""
        if since:
            query = """
                SELECT * FROM risk_signals
                WHERE (symbol = $1 OR underlying = $1) AND signal_time >= $2
                ORDER BY signal_time DESC
                LIMIT $3
            """
            records = await self._db.fetch(query, symbol, since, limit)
        else:
            query = """
                SELECT * FROM risk_signals
                WHERE symbol = $1 OR underlying = $1
                ORDER BY signal_time DESC
                LIMIT $2
            """
            records = await self._db.fetch(query, symbol, limit)

        return [self._to_entity(r) for r in records]

    async def find_breaches(
        self,
        severity: Optional[str] = None,
        since: Optional[datetime] = None,
        limit: int = 100,
    ) -> List[RiskSignal]:
        """Find breach signals."""
        conditions = ["signal_type = 'BREACH'"]
        params = []
        param_idx = 1

        if severity:
            conditions.append(f"severity = ${param_idx}")
            params.append(severity)
            param_idx += 1

        if since:
            conditions.append(f"signal_time >= ${param_idx}")
            params.append(since)
            param_idx += 1

        params.append(limit)

        query = f"""
            SELECT * FROM risk_signals
            WHERE {' AND '.join(conditions)}
            ORDER BY signal_time DESC
            LIMIT ${param_idx}
        """
        records = await self._db.fetch(query, *params)
        return [self._to_entity(r) for r in records]

    async def get_signal_counts_by_type(
        self,
        since: Optional[datetime] = None,
    ) -> Dict[str, int]:
        """Get count of signals by type."""
        if since:
            query = """
                SELECT signal_type, COUNT(*) as count
                FROM risk_signals
                WHERE signal_time >= $1
                GROUP BY signal_type
            """
            records = await self._db.fetch(query, since)
        else:
            query = """
                SELECT signal_type, COUNT(*) as count
                FROM risk_signals
                GROUP BY signal_type
            """
            records = await self._db.fetch(query)

        return {r["signal_type"]: r["count"] for r in records}


class TradeSignalRepository(BaseRepository[TradeSignal]):
    """Repository for trade signals."""

    def __init__(self, db: Database):
        super().__init__(db)

    @property
    def table_name(self) -> str:
        return "trade_signals"

    def _to_entity(self, record: Record) -> TradeSignal:
        """Convert database record to TradeSignal entity."""
        return TradeSignal(
            id=record["id"],
            signal_time=record["signal_time"],
            signal_source=record["signal_source"],
            signal_type=record["signal_type"],
            symbol=record["symbol"],
            underlying=record["underlying"],
            direction=record["direction"],
            confidence=record["confidence"],
            payload=self._from_json(record["payload"]),
            executed=record["executed"],
            execution_time=record["execution_time"],
            execution_order_id=record["execution_order_id"],
            created_at=record["created_at"],
        )

    def _to_row(self, entity: TradeSignal) -> Dict[str, Any]:
        """Convert TradeSignal entity to database row."""
        return {
            "signal_time": entity.signal_time,
            "signal_source": entity.signal_source,
            "signal_type": entity.signal_type,
            "symbol": entity.symbol,
            "underlying": entity.underlying,
            "direction": entity.direction,
            "confidence": entity.confidence,
            "payload": self._to_json(entity.payload),
            "executed": entity.executed,
            "execution_time": entity.execution_time,
            "execution_order_id": entity.execution_order_id,
        }

    async def find_by_source(
        self,
        signal_source: str,
        since: Optional[datetime] = None,
        limit: int = 100,
    ) -> List[TradeSignal]:
        """Find signals by source (strategy)."""
        if since:
            query = """
                SELECT * FROM trade_signals
                WHERE signal_source = $1 AND signal_time >= $2
                ORDER BY signal_time DESC
                LIMIT $3
            """
            records = await self._db.fetch(query, signal_source, since, limit)
        else:
            query = """
                SELECT * FROM trade_signals
                WHERE signal_source = $1
                ORDER BY signal_time DESC
                LIMIT $2
            """
            records = await self._db.fetch(query, signal_source, limit)

        return [self._to_entity(r) for r in records]

    async def find_pending(
        self,
        signal_source: Optional[str] = None,
        limit: int = 100,
    ) -> List[TradeSignal]:
        """Find signals that haven't been executed yet."""
        if signal_source:
            query = """
                SELECT * FROM trade_signals
                WHERE executed = FALSE AND signal_source = $1
                ORDER BY signal_time DESC
                LIMIT $2
            """
            records = await self._db.fetch(query, signal_source, limit)
        else:
            query = """
                SELECT * FROM trade_signals
                WHERE executed = FALSE
                ORDER BY signal_time DESC
                LIMIT $1
            """
            records = await self._db.fetch(query, limit)

        return [self._to_entity(r) for r in records]

    async def find_by_symbol(
        self,
        symbol: str,
        since: Optional[datetime] = None,
        limit: int = 100,
    ) -> List[TradeSignal]:
        """Find signals for a specific symbol."""
        if since:
            query = """
                SELECT * FROM trade_signals
                WHERE (symbol = $1 OR underlying = $1) AND signal_time >= $2
                ORDER BY signal_time DESC
                LIMIT $3
            """
            records = await self._db.fetch(query, symbol, since, limit)
        else:
            query = """
                SELECT * FROM trade_signals
                WHERE symbol = $1 OR underlying = $1
                ORDER BY signal_time DESC
                LIMIT $2
            """
            records = await self._db.fetch(query, symbol, limit)

        return [self._to_entity(r) for r in records]

    async def mark_executed(
        self,
        signal_id: int,
        order_id: str,
        execution_time: Optional[datetime] = None,
    ) -> bool:
        """Mark a signal as executed."""
        from src.utils.timezone import now_utc

        exec_time = execution_time or now_utc()

        query = """
            UPDATE trade_signals
            SET executed = TRUE,
                execution_time = $2,
                execution_order_id = $3
            WHERE id = $1
        """
        result = await self._db.execute(query, signal_id, exec_time, order_id)
        return "UPDATE 1" in result

    async def get_execution_stats(
        self,
        signal_source: Optional[str] = None,
        since: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """Get execution statistics for signals."""
        conditions = []
        params = []
        param_idx = 1

        if signal_source:
            conditions.append(f"signal_source = ${param_idx}")
            params.append(signal_source)
            param_idx += 1

        if since:
            conditions.append(f"signal_time >= ${param_idx}")
            params.append(since)

        where_clause = f"WHERE {' AND '.join(conditions)}" if conditions else ""

        query = f"""
            SELECT
                COUNT(*) as total_signals,
                SUM(CASE WHEN executed THEN 1 ELSE 0 END) as executed_count,
                COUNT(DISTINCT signal_source) as source_count,
                COUNT(DISTINCT symbol) as symbol_count
            FROM trade_signals
            {where_clause}
        """
        record = await self._db.fetchrow(query, *params)

        return {
            "total_signals": record["total_signals"] or 0,
            "executed_count": record["executed_count"] or 0,
            "source_count": record["source_count"] or 0,
            "symbol_count": record["symbol_count"] or 0,
            "execution_rate": (
                (record["executed_count"] / record["total_signals"])
                if record["total_signals"]
                else 0.0
            ),
        }
